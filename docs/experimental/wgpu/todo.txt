# TODO: create an example that involves multiple cubes, picking, textures, and a small shader that updates the vertices of the cubes.

# TODO: write an issue for pygfx to get more information on how to get vertex info (can quote)
# - visualize large numbers of primitives (40,000... 1,000,000?)
# - figure out how to only use 1 shader for all primitives (shared)
# - check lighting_info part of built-in shader
# - further fragment tests

Performance gets REALLY bad with certain InstancedMesh setups. Maybe an issue with overlapping meshes? Maybe just a parsing problem?
Bizzare triangulation when zooming in

Learned:
cause of slow mesh performance isn't number of triangles on screen, but the number of meshes
scene.add() is just a list and the longer that list is the longer the process takes
overlapping shapes have weird performance problem?
super easy to do shaders cause wgpu has direct shadertoy support

Shader that can parse geometry information?

-Write WGPU-level instancing example!

-Instancing many lines? Wouldn't they need something similar to what we need?
-Why don't they support multi-line rendering, such as fur?


Profiling:

10 x 10 object:
1.15s load time, 2-4 ms frame time

50 x 50
1.21s load time, 3-4ms frame time

100 x 100
1.39s load time, 2-4ms frame time

250 x 250
2.24s load time, 4ms frame time

500 x 500
6.01s load time, 4ms frame time

750 x 750 
12.0s load time, 4ms frame time

999 x 999
22.07s load time, 4ms frame time

all times ~50% slower when off charger

-attempt adding variables into the vertex shader

-mesh shader has a vertex shader which multiplies a alfine of each individual cube to the specific matrix
    -need to somehow access that instance (if you try to fetch the alfine you can, but you can not update)
    -ask if you can fetch the alfine the transforms from the shader and update it

    -how much of the webgpu is actually "web"?
    -how does pygfx get parsed to actual HTML/JS?

    -standards are built but nobody actually has done everything with buffer communication (completely freed from the machine languages)

-needs support for boids


write a cube... write the vertices of a cube replicate it with a transformation and use NaNs

vector of three nans
get indices automatically with picking??

wgpu buffer size? limit of ~30,000,000 (prevents 1 million)
-You can use multiple smaller buffers and make multiple meshes

picking and rotations on the np.nan version of the cubes?

InstanceInfo struct in vertex shader - WGLSL

3/29:

With face index is that enough? Giving the quad / triangle 

What you can do is create a dict? where you know where every triangle maps to every cube (section in the positions array)
Could allow for constant time lookup by having a mapping that says, for exmample: "cube 0 contains vertices[0:4] and faces are faces[0:6]"
So given face_index O(1) lookup of the cube.

If you don't want to work with ranges:
Create two complentary maps. One gives the ID of the cube like [0,0,0,0,0...1,1,1,1,1....] so that you can do instant lookup for the cube ID.

So like face_index 0, = IDs[0] gets you cube ID 0 which contains vertices 1-4... O(1)!

Ask pygfx folks if they store IDs for cubes.

Since we use NaNs in the Indices array as well, it helps with construction cause when we add the NaNs we can increment the lookup table IDs!

Also lookups allow for the transforms to be applied in the GPU.



IF GET ROTATIONS DONE!
Start work on getting rotations done with compute shaders!

For py lin alg?
Check rotation of matrixes. Maybe quaternion -> matrix * original positions matrix? IS IT A MATRIX?

Need to apply the matrix to the positions myself. glRotate from Wish.com

